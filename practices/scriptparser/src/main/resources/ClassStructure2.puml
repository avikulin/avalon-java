@startuml
'https://plantuml.com/class-diagram
interface SourceRepo{
    +void LoadFile(File file)
    +void LoadText(String[] source)
    +String next()
}

SourceRepo ..|>Iterable

class ScriptFile implements SourceRepo {
    -ArrayList<String> sourceStorage
    -int readPointer
    +void Load(File file)
    +void LoadText(String[] source)
    +String next()
}

interface DiagnosticLogger{
    +void trace(Class<?> source, EventType t, String event)
    +String getLog()
}

class Tracer implements DiagnosticLogger{
    -StringBuilder logStorage
    +void trace(Class<?> source, EventType t, String event)
    +String getLog()
}

DiagnosticLogger..>EventType

interface LexicalAnalyzer{
    +Command analyze(String source)
}

class LexicalParser implements LexicalAnalyzer {
        +Statement analyze(String source)
}

LexicalParser ..>Statement

interface TreeNode{
    NodeType getType()
    OperatorType getOperation()
    TreeNode getParent()
    TreeNode getLeft()
    TreeNode getRight()
}
TreeNode..>NodeType
TreeNode..>OperatorType

class ExpressionNode implements TreeNode{
    -NodeType type
    -OperatorType operator
    -ExpressionNode left
    -ExpressionNode right
    +NodeType getType
    +OperatorType getOperation()
    +TreeNode getLeft()
    +TreeNode getRight()
}

ExpressionNode-->NodeType
ExpressionNode-->OperatorType


interface ExpressionAnalyzer{
    +Expression parseCommand(Command command)
}

class SetGrammarParser implements ExpressionAnalyzer{
    +Expression parseCommand(Command command)
}

class PrintGrammarParser implements ExpressionAnalyzer{
    +Expression parseCommand(Command command)
}


interface Interpreter{
    +void setVariableContext(HashMap<String, Double> context)
    +void setResultContext(StringBuilder context)
    +void setLogContext(DiagnosticLogger context)
    +void interpret(Expression expression)
}

class SetCommandInterpreter implements Interpreter{
    +void setVariableContext(HashMap<String, Double> context)
    +void setResultContext(StringBuilder context)
    +void setLogContext(DiagnosticLogger context)
    +void interpret(Expression expression)
}

class PrintCommandInterpreter implements Interpreter{
    +void setVariableContext(HashMap<String, Double> context)
    +void setResultContext(StringBuilder context)
    +void setLogContext(DiagnosticLogger context)
    +void interpret(Expression expression)
}

class TraceCommandInterpreter implements Interpreter{
    +void setVariableContext(HashMap<String, Double> context)
    +void setResultContext(StringBuilder context)
    +void setLogContext(DiagnosticLogger context)
    +void interpret(Expression expression)
}


class ScriptManager{
    -LexicalAnalyzer cmdAnalyzer
    -HashMap<CommandType, ExpressionAnalyzer> analysisContext
    -HashMap<CommandType, ExpressionAnalyzer> interpretationContext
    -DiagnosticLogger loggingContext
    -Deque<Expression> executionContext
    -StringBuilder resultContext
    +loadFile(File f)
    +loadText(String[] source)
    +registerLexicalAnalyzer(LexicalAnalyzer obj)
    +registerGrammarAnalyzer(CommandType type, ExpressionAnalyzer obj)
    +registerExpressionInterpreter(CommandType type, Interpreter obj)
    +runScript()
}

ScriptManager --> LexicalAnalyzer
ScriptManager o--> ExpressionAnalyzer
ScriptManager o--> Interpreter
ScriptManager o--> Expression
ScriptManager --> DiagnosticLogger
ScriptManager -->SourceRepo

interface SubTree{
   +int getSign()
   +TreeNode getRoot()
}

interface Expression{
    +CommandType getType()
    +void visit(Consumer<? super TreeNode node>)
}

interface Iterable{}
Expression --|>Statement

Expression ..|>CommandType

class SetExpression implements Expression{
    -CommandType type
    -String lvalue
    -ArrayList<ExpressionToken> rvalue
    +int getId()
    +CommandType getType()
    +String getLValue()
    +boolean hasLValue()
    +String getRValue()
    +boolean hasRValue()
    +void addToken(ExpressionToken token)
    +Iterator<ExpressionToken> iterator()
}

SetExpression o-->SubTree
SetExpression -->CommandType

class PrintExpression implements Expression{
    -CommandType type
    -ArrayList<TreeNode> tokens
}

PrintExpression o-->TreeNode
PrintExpression -->CommandType

class TraceExpression implements Expression{
    -CommandType type
    +CommandType getType()
}
TraceExpression -->CommandType

class ExpressionToken implements SubTree {
    -int sign
    -TreeNode subTree
    +int getSign()
    +TreeNode getRoot()
}

SubTree..>TreeNode
ExpressionToken-->TreeNode

interface Statement{
    int getId()
    CommandType getType()
    String getLValue()
    boolean hasLValue()
    String getRValue()
    boolean hasRValue()
}
Statement..>CommandType
class Command implements Statement{
    -int id
    -CommandType type
    -String lvalue
    -ArrayList<Token> rvalue
    +int getId()
    +CommandType getType()
    +String getLValue()
    +boolean hasLValue()
    +String getRValue()
    +boolean hasRValue()
}

Command --> CommandType

enum EventType{
    ERROR
    INFO
}

enum OperatorType{
    SUM
    SUB
    MUL
    DIV
    CONSTANT
}

enum CommandType{
    SET
    PRINT
    TRACE
}

enum NodeType{
    STRING_LITERAL
    NUMBER_LITERAL
    VARIABLE
    EXPRESSION
}

@enduml